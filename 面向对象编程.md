# 面向对象编程
**面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。**

**Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student**，比如，Bart Simpson和Lisa Simpson是两个具体的Student：
所以，**面向对象的设计思想是抽象出Class，根据Class创建Instance**。

## 类和实例
1. **牢记类是抽象的模板**，比如Student类，而**实例是根据类创建出来的一个个具体的“对象”**，每个对象都拥有相同的方法，但各自的数据可能不同
2. **类名通常是大写开头的单词**，紧接着是(object)，表示该类是从哪个类继承下来的，**通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类**
3. 通过**定义一个特殊的__init__方法**，在创建实例的时候，就把name，score等属性绑上去：
```
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score
```
**在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。**

4. 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传
```
>>> bart = Student('Bart Simpson', 59)
>>> bart.name
'Bart Simpson'
>>> bart.score
59
```

## 数据封装
```
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print '%s: %s' % (self.name, self.score)
```
要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入
```
>>> bart.print_score()
Bart Simpson: 59
```
**封装的另一个好处是可以给Student类增加新的方法**

## 访问限制
从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：
```
>>> bart = Student('Bart Simpson', 98)
>>> bart.score
98
>>> bart.score = 59
>>> bart.score
59
```
如果要让内部属性不被外部访问，可以**把属性的名称前加上两个下划线__**，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：
```
class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print '%s: %s' % (self.__name, self.__score)
        
        
>>> bart = Student('Bart Simpson', 98)
>>> bart.__name
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute '__name'
```
**这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮**

但是如果**外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：**
```
class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
```
如果又要允许外部代码修改score怎么办？可以给Student类增加set_score方法：
```
class Student(object):
    ...

    def set_score(self, score):
        self.__score = score
```
你也许会问，原先那种直接通过bart.score = 59也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，**可以对参数做检查，避免传入无效的参数：**
```
class Student(object):
    ...

    def set_score(self, score):
        if 0 <= score <= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
```
**变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名**

**双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是**。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：
```
>>> bart._Student__name
'Bart Simpson'
```
强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。

## 继承和多态
当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而**被继承的class称为基类、父类或超类（Base class、Super class）**。

比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：
```
class Animal(object):
    def run(self):
        print 'Animal is running...'
```
### 继承
当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：
```
class Dog(Animal):
    pass

class Cat(Animal):
    pass
```
**对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。**
```
dog = Dog()
dog.run()

Animal is running...
```
也可以**对子类增加一些方法**，比如Dog类：
```
class Dog(Animal):
    def run(self):
        print 'Dog is running...'
    def eat(self):
        print 'Eating meat...'
```
### 多态
当子类和父类**都存在相同的run()方法时**，我们说，**子类的run()覆盖了父类的run()**，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。

要理解什么是多态，我们首先要对数据类型再作一点说明。当我们**定义一个class的时候，我们实际上就定义了一种数据类型**。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：
```
a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
```
判断一个变量是否是某个类型可以用isinstance()判断：
```
>>> isinstance(a, list)
True
>>> isinstance(b, Animal)
True
>>> isinstance(c, Dog)
True
```
看来a、b、c确实对应着list、Animal、Dog这3种类型。
但是等等，试试：
```
>>> isinstance(c, Animal)
True
```
c不仅仅是Dog，c还是Animal！

#### 多态的好处
要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：
def run_twice(animal):
    animal.run()
    animal.run()
当我们传入Animal的实例时，run_twice()就打印出：
>>> run_twice(Animal())
Animal is running...
Animal is running...
当我们传入Dog的实例时，run_twice()就打印出：
>>> run_twice(Dog())
Dog is running...
Dog is running...
看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：
class Tortoise(Animal):
    def run(self):
        print 'Tortoise is running slowly...'
当我们调用run_twice()时，传入Tortoise的实例：
>>> run_twice(Tortoise())
Tortoise is running slowly...
Tortoise is running slowly...

你会发现，**新增一个Animal的子类，不必对run_twice()做任何修改**，实际上，**任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行**，原因就在于多态。

1. 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：
对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定
2. 这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：

>>> 对扩展开放：允许新增Animal子类；

>>> 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。

**继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系**。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。
